# 第一章、操作系统概述

**操作系统**：资源的管理器。

**操作系统的功能**：

- **用户(命令)接口**：操作系统实现的所有用户命令所构成的集合。
- **程序接口**：操作系统实现的所有系统调用所构成的集合。

**系统调用**：由操作系统实现的应用软件在运行过程中可以引用的系统服务。

## 1. 重要概念

**作业**：计算机用户在一次上上机过程中要求计算机系统为其所做工作的集合。

**联机作业**：计算机用户不能在此类作业被计算机系统处理时改变已经定义好的作业步。

**脱机作业**：计算机用户可以在此类作业被计算机系统处理时**随时改变**改变其作业步。

**线程(Thread)：线程是指程序的一次相对独立的运行过程(强调是动态的)，在现代操作系统中，线程是程序调度的最小单位**。

**进程(Process)：进程是指系统分配资源的基本对象；在现代操作系统中，进程仅仅是系统中拥有资源的最小实体；不过，在传统的操作系统中，进程也是系统调度的最小单位**。

**虚拟存储**：进程的逻辑地址空间。将外存的部分空间虚拟为内存使用。



## 2. 操作系统的发展

### 2.1. 单道批处理系统

<img src="https://img-blog.csdnimg.cn/20201113192316519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JyaW5nb18=,size_16,color_FFFFFF,t_70#pic_center" alt="单道批处理系统" style="zoom:150%;" />

**核心问题**：单道批处理系统的效率很低。



### 2.2. 多道批处理系统

![多道批处理系统](https://img-blog.csdnimg.cn/20201113193909943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JyaW5nb18=,size_16,color_FFFFFF,t_70#pic_center)

**多道批处理系统中，A进程执行结束后，释放CPU，B进程才能占有CPU资源**。

**核心问题**：**同步、互斥、死锁、人机交互问题**。



### 2.3. 分时系统

**分时系统**：

- 处理器的时间被多个用户共享。

- 多用户通过多个终端去访问系统。

**分时系统时间片到了之后，就会切换到下一个任务，并不是当前任务想不想释放CPU的问题，是必须释放CPU**。

|                | 多道批处理系统             | 分时系统               |
| -------------- | -------------------------- | ---------------------- |
| 主要目标       | 最大限度提高CPU的使用率    | 最大限度降低响应时间   |
| 操作系统的指令 | 作业控制语言提供相应的指令 | 用户通过终端来提交指令 |



# 第二章、进程

## 1. 进程和状态

**程序顺序执行时的特征**：顺序性、封闭性、可再现性。

**程序并发执行时的特征**：间断性、非封闭性、不可再现性(转账和取钱问题)。

**程序并发执行的条件**：`R(p1) ∩ W(p2) ∪ W(p1) ∩ R(p2) ∪ W(p1) ∩ W(p2) = {} `。**读和写是完全互斥的(事务管理)**。

**进程的结构**：程序、数据、PCB(Process Control Block)。



### 1.1. 进程的五种状态

**创建(New)**：进程已经被创建，但未被操作系统接纳为可执行进程。

**就绪态(Ready)**：程序准备执行。"万事俱备，只欠CPU"。

**运行态(Running)**：占用CPU（单处理器环境中，某时刻仅有一个进程占用处理机）。

**阻塞态(Blocked)**：等待某事件发生才能执行，如等待I/O完成等。

**退出(Exit)**：因停止或取消，被操作系统从执行状态释放。

![状态转换图](https://img-blog.csdnimg.cn/20201114203458559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JyaW5nb18=,size_16,color_FFFFFF,t_70#pic_center)



### 1.2. 进程的挂起状态

**(1)交换技术**：将内存中暂时不能运行的进程，或暂时不能用的数据和程序，Swapping-out到外存，以腾出足够的内存空间，把已具备运行条件的进程，或进程所需要的数据和程序，Swapping-in进内存。

**(2)挂起状态的原因**：

- 处理器的状态比I/O快很多；
- 所有进程可能会等待I/O，处理器空闲了。

**(3)解决办法**：

- 将上述进程交换到磁盘中以释放更多的内存。
- 将把进程交换到磁盘中时，处于阻塞态的进程就切换为**挂起状态**。

**(4)被挂起的进程的特征**：

- 不能立即执行。
- 可能是等待某事件发生。若是，**则阻塞条件独立于挂起条件**，即使阻塞事件发生，该进程也不能执行。（阻塞状态解除对挂起状态是没有影响的）。

- 使之挂起的进程为：自己、其父进程、操作系统。
- 只有挂起它的进程才能使之由挂起状态转换为其他状态。

**(5)挂起和阻塞**？

1. 是否只能挂起阻塞进程？

   答：不一定，但是有时候会优先挂起阻塞进程。

2. 如何激活一个挂起进程？

   答：将进程从磁盘中交换进内存。

**(6)区分两个概念**：

1. 进程是否等待事件？

   答：阻塞与否。

2. 进程是否被换出内存？

   答：挂起与否。

**(7)4种状态组合**：

- **就绪态**：进程在内存，准备执行。
- **阻塞态**：进程在内存，等待事件。
- **就绪、挂起**：进程在外存，只要调入内存即可。
- **阻塞、挂起**：进程在外存，等待事件。 

![进程七种状态](https://img-blog.csdnimg.cn/20201114213108502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JyaW5nb18=,size_16,color_FFFFFF,t_70#pic_center)



## 2. 进程控制块

**Process Control Block**：简称PCB，是操作系统控制和管理进程所用的基本数据结构。

**PCB作用**：PCB是相关进程存在于系统中的唯一标志；系统根据PCB而感知相关进程的存在。



## 3. 进程切换：原语

**原语：不可中断**。

**(1)进程切换过程**：

1. 包含寄存器和计数器的处理器上下文会被保存。
2. 更新进程的PCB。
3.  将PCB移动到相应的队列中（根据中断情况不同可能是就绪队列，或是阻塞队列）。
4. 选择另外一个进程来执行。
5. 更新当前选中进程的PCB。
6. 更新内存管理的数据结构。
7. 恢复被选中程序的上下文（数据和PCB）。

**(2)进程的创建和终止**。

**进程创建**：

1. **为进程分配一个唯一的ID标识号**：主进程表中增加一个新的表项；
2. **为进程分配空间**：用户地址空间、用户栈空间、PCB空间。若共享已有空间，则应创建相应的链接。
3. **初始化PCB**：进程标识、处理机状态信息、进程状态。
4. **建立链接**：若调度队列是链表，则将新进程插入到就绪或（就绪，挂起）链表。

**进程终止**：

1. 根据被终止进程的ID，找到其PCB，读出该进程的状态；
2. 如果该进程为运行态，则终止其执行，调度新进程执行；
3. 如果该进程有子孙进程，则立即终止其所有子孙进程；
4. 将该进程的全部资源，或归还给其父进程，或归还给系统；
5. 被终止进程（PCB）从所在队列中移除，等待其他程序来搜集信息。

**(3)进程的阻塞和唤醒**。

**进程阻塞**：当出现阻塞事件，进程调用阻塞原语将自己阻塞，进程状态变为"阻塞状态"，并进入相应事件的阻塞队列。

**进程唤醒**：当阻塞进程期待的事件发生，有关进程调用唤醒原语，将等待该事件的进程唤醒，状态变为"就绪状态"，插入就绪队列。

**(4)进程的挂起和激活**。

**进程挂起**：当出现挂起事件，系统利用挂起原语将指定进程或阻塞状态进程挂起。进程从内存换到外存，状态改变：`ready-->ready,suspend;blocked-->blocked,suspend `，插入相应的队列。

**线程激活**：当激活事件发生，系统利用激活原语将指定进程激活。进程从外存换入到内存，状态改变：`ready,suspend-->ready; blocked,suspend-->blocked`。

## 3. 进程切换和模式切换

**进程切换**：**进程之间的一种操作**。当分派程序收回当前进程的CPU并准备把它分派给某个就绪进程时，该操作将被引用。

**模式切换**：**进程内部所引用的一种操作**。当执行核心子系统提供的系统调用的时候，用户态会切换到系统态，然后再从系统态切换回用户态。

**进程切换一定有模式切换，但是模式切换不一定有进程切换**。因为进程切换一定要执行调度程序，调度程序要在系统态中去执行，进程切换会有中断，中断在系统态中执行。



## 4. 线程

### 4.1. 进程和线程

**(1)进程：资源分配的单位**。

**(2)线程：调度的单位，线程是在进程的基础上创建的**。

1. 线程有执行状态（运行、就绪等）。
2. 线程中断的时候会保存线程的上下文。
3. 线程有执行栈，保存系统调用的数据。
4. 线程有少量局部变量空间。
5. 挂起一个进程，会挂起当前进程内的所有线程。
6. 进程终止，进程中的所有线程也会终止。
7. **线程可以访问它所在进程的内存和资源——所有的线程会共享它所在进程的资源**。

**(3)线程的好处**：

1. 创建线程比创建线程的时间少。
2. 终止线程比终止进程花的时间少。
3. 同一进程内的两个线程之间的切换用的时间少。
4. 同一进程内的多个线程，共享它所在进程的资源，因此线程之间彼此通信就不需要去激发操作系统内核，减少系统的开销。



### 4.2. 线程分类

**(1)用户级线程**：

- 在应用程序中完成所有线程的管理。
- 操作系统内核不知道这些线程的存在。
- **在核外子系统实现——用户态**。

**(2)内核级线程**：

- 操作系统内核维护进程和线程的上下文信息。
- 基于线程进程调度。
- **在核心子系统实现——系统态**。

# 第三章、进程的调度

## 1. 调度类型

**(1)调度目标**

- 响应时间（Response Time）。
- 系统吞吐量（Throughput）。

**(2)调度类型**

- 按操作系统类型划分：批处理调度、分时调度、实时调度、多处理机调度。
- 按调度的层次划分：长程调度、中程调度、短程调度。



**(3)长程调度**：又称为高级调度、作业调度。为被调度作业或用户程序创建进程、分配必要的系统资源，并将新创建的进程插入**就绪队列，等待短程调度**。

- 决定哪个程序被允许进入到内存并创建进程？—— 这取决于调度算法，如FCFS、短作业优先、基于优先权、响应比高者优先等调度算法。

- 选多少程序进入到内存中去？—— 这取决于多道程序的度。

- 什么时候会执行作业调度？—— 有作业退出了（完成）；处理器空闲了。



**(4)中程调度**：又称为中级调度，将换出到磁盘的进程调度到内存，准备执行，

- 中程调度配合对换技术使用。
- 中程调度的目的是为了提高内存的利用率和系统吞吐量。
- 在多道程序度允许的情况下，从外存选择一个挂起状态的进程调度到内存（换入）。



**(5)短程调度**：又称为进程调度、低级调度。调度内存中就绪进程执行。

- **决定就绪队列哪个进程获得处理机**。
- 进程调度执行非常频繁。
- 引起进程调度的事件：时钟中断、I/O中断、操作系统调用、信号。



## 2. 调度准则

**(1)面向用户**：

- 响应时间：提交命令直到产生结果所用的时间。**常用于评价分时系统的性能**。
- 周转时间：作业提交给系统开始，到作业完成为止的这段时间间隔（也称为作业周转时间）。**常用于评价批处理系统的性能**。
- 截止时间：某任务必须开始执行的最迟时间（或必须完成的最迟时间）。**常用于评估实时系统的性能**。

**(2)面向系统**：

- 吞吐量：单位时间内系统所完成的作业数。**用于评价批处理系统的性能指标**。

- 处理机利用率：处理机忙碌的百分比，处理机的利用是有效的且高效的。
- 资源的平衡使用：使系统中的资源保持动态的平衡。**适用于长程调度和中程调度**。
- 公平性：所有进程要求被公平对待，尽量没有进程遭遇饥饿。
- 优先级：调度程序总是选择高优先级的优先运行。根据优先级不同可以有多种就绪队列。





## 3. 调度算法

> 决策模式

**(1)非剥夺模式**：程序一旦处于运行状态，只有该程序主动终止或者阻塞(如I/O)才会释放处理机。

**当前程序主动释放CPU，主要用于批处理系统**。

**(2)剥夺模式**：当前运行的进程可能会被中断，然后被操作系统将其移到就绪态。

**当前程序被强制中断，任何程序都不能长时间垄断地独占处理器， 主要用于实时性高实时系统，和性能要求高的批处理系统和分时系统**。



> 调度算法

<img src="https://img-blog.csdnimg.cn/20201130224910309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JyaW5nb18=,size_16,color_FFFFFF,t_70" alt="例子" style="zoom:150%;" />



**(1)先来先服务(非剥夺)**

![先来先服务](https://img-blog.csdnimg.cn/20201130225402567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JyaW5nb18=,size_16,color_FFFFFF,t_70)

**平均周转时间(要算上等待时间) =（20 + 1 + 5 + 7 + 10）/ 5 = 8.6** 。  

- 每一个进程都要加入到就绪队列。
- 当前进程停止执行（释放了CPU），排在就绪队列前边的进程会被选择去执行。
- **执行时间短的进程可能会等待很长的时间才能去执行**。
- **I/O型进程：占有CPU之后，很少时间占用CPU，剩下时间去I/O了，I/O型进程也可能要等待很长的时间才能执行**。



**(2)高响应比优先(剥夺)**

响应比 = ( 等待时间 + 要求服务时间 ) / 要求服务时间。



**(3)时间片轮转调度算法**：

公平、轮流地为各个进程服务。进程的时间片运行结束后，剥夺处理机，将进程放到就绪队列尾部重新进行排队。





## 4. 实时调度





